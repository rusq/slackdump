// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/rusq/slackdump/v4/internal/chunk/control (interfaces: Streamer,TransformStarter,ExportTransformer,ReferenceChecker,EncodeReferenceCloser)
//
// Generated by this command:
//
//	mockgen -destination=mock_control/mock_interfaces.go . Streamer,TransformStarter,ExportTransformer,ReferenceChecker,EncodeReferenceCloser
//

// Package mock_control is a generated GoMock package.
package mock_control

import (
	context "context"
	reflect "reflect"

	slack "github.com/rusq/slack"
	chunk "github.com/rusq/slackdump/v4/internal/chunk"
	structures "github.com/rusq/slackdump/v4/internal/structures"
	processor "github.com/rusq/slackdump/v4/processor"
	gomock "go.uber.org/mock/gomock"
)

// MockStreamer is a mock of Streamer interface.
type MockStreamer struct {
	ctrl     *gomock.Controller
	recorder *MockStreamerMockRecorder
	isgomock struct{}
}

// MockStreamerMockRecorder is the mock recorder for MockStreamer.
type MockStreamerMockRecorder struct {
	mock *MockStreamer
}

// NewMockStreamer creates a new mock instance.
func NewMockStreamer(ctrl *gomock.Controller) *MockStreamer {
	mock := &MockStreamer{ctrl: ctrl}
	mock.recorder = &MockStreamerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStreamer) EXPECT() *MockStreamerMockRecorder {
	return m.recorder
}

// Conversations mocks base method.
func (m *MockStreamer) Conversations(ctx context.Context, proc processor.Conversations, links <-chan structures.EntityItem) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Conversations", ctx, proc, links)
	ret0, _ := ret[0].(error)
	return ret0
}

// Conversations indicates an expected call of Conversations.
func (mr *MockStreamerMockRecorder) Conversations(ctx, proc, links any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Conversations", reflect.TypeOf((*MockStreamer)(nil).Conversations), ctx, proc, links)
}

// ListChannels mocks base method.
func (m *MockStreamer) ListChannels(ctx context.Context, proc processor.Channels, p *slack.GetConversationsParameters) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListChannels", ctx, proc, p)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListChannels indicates an expected call of ListChannels.
func (mr *MockStreamerMockRecorder) ListChannels(ctx, proc, p any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListChannels", reflect.TypeOf((*MockStreamer)(nil).ListChannels), ctx, proc, p)
}

// ListChannelsEx mocks base method.
func (m *MockStreamer) ListChannelsEx(ctx context.Context, proc processor.Channels, p *slack.GetConversationsParameters, onlyMyChannels bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListChannelsEx", ctx, proc, p, onlyMyChannels)
	ret0, _ := ret[0].(error)
	return ret0
}

// ListChannelsEx indicates an expected call of ListChannelsEx.
func (mr *MockStreamerMockRecorder) ListChannelsEx(ctx, proc, p, onlyMyChannels any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListChannelsEx", reflect.TypeOf((*MockStreamer)(nil).ListChannelsEx), ctx, proc, p, onlyMyChannels)
}

// SearchFiles mocks base method.
func (m *MockStreamer) SearchFiles(ctx context.Context, proc processor.FileSearcher, query string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchFiles", ctx, proc, query)
	ret0, _ := ret[0].(error)
	return ret0
}

// SearchFiles indicates an expected call of SearchFiles.
func (mr *MockStreamerMockRecorder) SearchFiles(ctx, proc, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchFiles", reflect.TypeOf((*MockStreamer)(nil).SearchFiles), ctx, proc, query)
}

// SearchMessages mocks base method.
func (m *MockStreamer) SearchMessages(ctx context.Context, proc processor.MessageSearcher, query string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchMessages", ctx, proc, query)
	ret0, _ := ret[0].(error)
	return ret0
}

// SearchMessages indicates an expected call of SearchMessages.
func (mr *MockStreamerMockRecorder) SearchMessages(ctx, proc, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchMessages", reflect.TypeOf((*MockStreamer)(nil).SearchMessages), ctx, proc, query)
}

// Users mocks base method.
func (m *MockStreamer) Users(ctx context.Context, proc processor.Users, opt ...slack.GetUsersOption) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, proc}
	for _, a := range opt {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Users", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Users indicates an expected call of Users.
func (mr *MockStreamerMockRecorder) Users(ctx, proc any, opt ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, proc}, opt...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Users", reflect.TypeOf((*MockStreamer)(nil).Users), varargs...)
}

// UsersBulk mocks base method.
func (m *MockStreamer) UsersBulk(ctx context.Context, proc processor.Users, ids ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, proc}
	for _, a := range ids {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UsersBulk", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UsersBulk indicates an expected call of UsersBulk.
func (mr *MockStreamerMockRecorder) UsersBulk(ctx, proc any, ids ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, proc}, ids...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsersBulk", reflect.TypeOf((*MockStreamer)(nil).UsersBulk), varargs...)
}

// UsersBulkWithCustom mocks base method.
func (m *MockStreamer) UsersBulkWithCustom(ctx context.Context, proc processor.Users, includeLabels bool, ids ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, proc, includeLabels}
	for _, a := range ids {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UsersBulkWithCustom", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UsersBulkWithCustom indicates an expected call of UsersBulkWithCustom.
func (mr *MockStreamerMockRecorder) UsersBulkWithCustom(ctx, proc, includeLabels any, ids ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, proc, includeLabels}, ids...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsersBulkWithCustom", reflect.TypeOf((*MockStreamer)(nil).UsersBulkWithCustom), varargs...)
}

// WorkspaceInfo mocks base method.
func (m *MockStreamer) WorkspaceInfo(ctx context.Context, proc processor.WorkspaceInfo) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WorkspaceInfo", ctx, proc)
	ret0, _ := ret[0].(error)
	return ret0
}

// WorkspaceInfo indicates an expected call of WorkspaceInfo.
func (mr *MockStreamerMockRecorder) WorkspaceInfo(ctx, proc any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WorkspaceInfo", reflect.TypeOf((*MockStreamer)(nil).WorkspaceInfo), ctx, proc)
}

// MockTransformStarter is a mock of TransformStarter interface.
type MockTransformStarter struct {
	ctrl     *gomock.Controller
	recorder *MockTransformStarterMockRecorder
	isgomock struct{}
}

// MockTransformStarterMockRecorder is the mock recorder for MockTransformStarter.
type MockTransformStarterMockRecorder struct {
	mock *MockTransformStarter
}

// NewMockTransformStarter creates a new mock instance.
func NewMockTransformStarter(ctrl *gomock.Controller) *MockTransformStarter {
	mock := &MockTransformStarter{ctrl: ctrl}
	mock.recorder = &MockTransformStarterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransformStarter) EXPECT() *MockTransformStarterMockRecorder {
	return m.recorder
}

// StartWithUsers mocks base method.
func (m *MockTransformStarter) StartWithUsers(ctx context.Context, users []slack.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartWithUsers", ctx, users)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartWithUsers indicates an expected call of StartWithUsers.
func (mr *MockTransformStarterMockRecorder) StartWithUsers(ctx, users any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartWithUsers", reflect.TypeOf((*MockTransformStarter)(nil).StartWithUsers), ctx, users)
}

// MockExportTransformer is a mock of ExportTransformer interface.
type MockExportTransformer struct {
	ctrl     *gomock.Controller
	recorder *MockExportTransformerMockRecorder
	isgomock struct{}
}

// MockExportTransformerMockRecorder is the mock recorder for MockExportTransformer.
type MockExportTransformerMockRecorder struct {
	mock *MockExportTransformer
}

// NewMockExportTransformer creates a new mock instance.
func NewMockExportTransformer(ctrl *gomock.Controller) *MockExportTransformer {
	mock := &MockExportTransformer{ctrl: ctrl}
	mock.recorder = &MockExportTransformerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExportTransformer) EXPECT() *MockExportTransformerMockRecorder {
	return m.recorder
}

// StartWithUsers mocks base method.
func (m *MockExportTransformer) StartWithUsers(ctx context.Context, users []slack.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartWithUsers", ctx, users)
	ret0, _ := ret[0].(error)
	return ret0
}

// StartWithUsers indicates an expected call of StartWithUsers.
func (mr *MockExportTransformerMockRecorder) StartWithUsers(ctx, users any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartWithUsers", reflect.TypeOf((*MockExportTransformer)(nil).StartWithUsers), ctx, users)
}

// Transform mocks base method.
func (m *MockExportTransformer) Transform(ctx context.Context, channelID, threadID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Transform", ctx, channelID, threadID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Transform indicates an expected call of Transform.
func (mr *MockExportTransformerMockRecorder) Transform(ctx, channelID, threadID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transform", reflect.TypeOf((*MockExportTransformer)(nil).Transform), ctx, channelID, threadID)
}

// MockReferenceChecker is a mock of ReferenceChecker interface.
type MockReferenceChecker struct {
	ctrl     *gomock.Controller
	recorder *MockReferenceCheckerMockRecorder
	isgomock struct{}
}

// MockReferenceCheckerMockRecorder is the mock recorder for MockReferenceChecker.
type MockReferenceCheckerMockRecorder struct {
	mock *MockReferenceChecker
}

// NewMockReferenceChecker creates a new mock instance.
func NewMockReferenceChecker(ctrl *gomock.Controller) *MockReferenceChecker {
	mock := &MockReferenceChecker{ctrl: ctrl}
	mock.recorder = &MockReferenceCheckerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReferenceChecker) EXPECT() *MockReferenceCheckerMockRecorder {
	return m.recorder
}

// IsComplete mocks base method.
func (m *MockReferenceChecker) IsComplete(ctx context.Context, channelID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsComplete", ctx, channelID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsComplete indicates an expected call of IsComplete.
func (mr *MockReferenceCheckerMockRecorder) IsComplete(ctx, channelID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsComplete", reflect.TypeOf((*MockReferenceChecker)(nil).IsComplete), ctx, channelID)
}

// IsCompleteThread mocks base method.
func (m *MockReferenceChecker) IsCompleteThread(ctx context.Context, channelID, threadID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCompleteThread", ctx, channelID, threadID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCompleteThread indicates an expected call of IsCompleteThread.
func (mr *MockReferenceCheckerMockRecorder) IsCompleteThread(ctx, channelID, threadID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCompleteThread", reflect.TypeOf((*MockReferenceChecker)(nil).IsCompleteThread), ctx, channelID, threadID)
}

// MockEncodeReferenceCloser is a mock of EncodeReferenceCloser interface.
type MockEncodeReferenceCloser struct {
	ctrl     *gomock.Controller
	recorder *MockEncodeReferenceCloserMockRecorder
	isgomock struct{}
}

// MockEncodeReferenceCloserMockRecorder is the mock recorder for MockEncodeReferenceCloser.
type MockEncodeReferenceCloserMockRecorder struct {
	mock *MockEncodeReferenceCloser
}

// NewMockEncodeReferenceCloser creates a new mock instance.
func NewMockEncodeReferenceCloser(ctrl *gomock.Controller) *MockEncodeReferenceCloser {
	mock := &MockEncodeReferenceCloser{ctrl: ctrl}
	mock.recorder = &MockEncodeReferenceCloserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEncodeReferenceCloser) EXPECT() *MockEncodeReferenceCloserMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockEncodeReferenceCloser) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockEncodeReferenceCloserMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockEncodeReferenceCloser)(nil).Close))
}

// Encode mocks base method.
func (m *MockEncodeReferenceCloser) Encode(ctx context.Context, arg1 *chunk.Chunk) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Encode", ctx, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Encode indicates an expected call of Encode.
func (mr *MockEncodeReferenceCloserMockRecorder) Encode(ctx, arg1 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encode", reflect.TypeOf((*MockEncodeReferenceCloser)(nil).Encode), ctx, arg1)
}

// IsComplete mocks base method.
func (m *MockEncodeReferenceCloser) IsComplete(ctx context.Context, channelID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsComplete", ctx, channelID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsComplete indicates an expected call of IsComplete.
func (mr *MockEncodeReferenceCloserMockRecorder) IsComplete(ctx, channelID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsComplete", reflect.TypeOf((*MockEncodeReferenceCloser)(nil).IsComplete), ctx, channelID)
}

// IsCompleteThread mocks base method.
func (m *MockEncodeReferenceCloser) IsCompleteThread(ctx context.Context, channelID, threadID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsCompleteThread", ctx, channelID, threadID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsCompleteThread indicates an expected call of IsCompleteThread.
func (mr *MockEncodeReferenceCloserMockRecorder) IsCompleteThread(ctx, channelID, threadID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCompleteThread", reflect.TypeOf((*MockEncodeReferenceCloser)(nil).IsCompleteThread), ctx, channelID, threadID)
}
